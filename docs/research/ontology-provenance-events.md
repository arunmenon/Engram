# Provenance and Event Ontologies: Deep Dive for Context-Graph

Date: 2026-02-11
Status: Research deliverable for ADR-0011 (Task #2)
Depends on: ontology-discovery.md (Task #1)

## Purpose

This document provides a deep analysis of provenance ontologies and event/activity models relevant to grounding the context-graph project's edge types, node types, and event schema in formal standards. It answers four key questions:

1. Can W3C PROV-O serve as the foundational ontology for causal edges and attribution?
2. Which event ontology best fits our dot-namespaced event types?
3. What is the gap between our current schema and a PROV-O-grounded model?
4. Are there existing mappings between PROV-O and OpenTelemetry?

---

## 1. W3C PROV-O: Detailed Analysis

### 1.1 Three-Tier Structure

PROV-O organizes its vocabulary into three tiers designed for incremental adoption:

**Tier 1 -- Starting Point** (minimal viable provenance):
- Three classes: `Entity`, `Activity`, `Agent`
- Seven binary properties: `wasGeneratedBy`, `used`, `wasDerivedFrom`, `wasAttributedTo`, `wasAssociatedWith`, `actedOnBehalfOf`, `wasInformedBy`
- Temporal properties: `startedAtTime`, `endedAtTime`
- Sufficient for simple provenance chains

**Tier 2 -- Expanded Terms** (domain-specific elaboration):
- Agent subclasses: `Person`, `Organization`, `SoftwareAgent`
- Entity subclasses: `Collection`, `Bundle`, `Plan`
- Derivation specializations: `wasQuotedFrom`, `wasRevisionOf`, `hadPrimarySource`
- Lifecycle properties: `generatedAtTime`, `invalidatedAtTime`, `wasInvalidatedBy`, `wasStartedBy`, `wasEndedBy`
- Abstraction: `specializationOf`, `alternateOf`
- Collection membership: `hadMember`
- Location: `atLocation`
- Inverse properties: `generated`, `invalidated`

**Tier 3 -- Qualified Terms** (metadata on relationships):
- Reified influence classes: `Generation`, `Usage`, `Derivation`, `Attribution`, `Association`, `Communication`, `Delegation`
- Expanded influence classes: `Influence`, `PrimarySource`, `Quotation`, `Revision`, `Invalidation`, `Start`, `End`
- Qualifier properties: `qualifiedGeneration`, `qualifiedUsage`, `qualifiedDerivation`, `qualifiedAttribution`, `qualifiedAssociation`, `qualifiedCommunication`, `qualifiedDelegation`
- Annotation properties: `atTime`, `hadPlan`, `hadRole`, `hadActivity`, `hadUsage`, `hadGeneration`

### 1.2 The Qualification Pattern

The qualification pattern is PROV-O's mechanism for attaching metadata to relationships. It reifies a binary relation into an intermediate class that can carry additional properties.

**Unqualified form** (simple):
```
:event1 prov:wasInformedBy :event0 .
```

**Qualified form** (with metadata):
```
:event1 prov:qualifiedCommunication :comm1 .
:comm1  a prov:Communication ;
        prov:activity :event0 ;
        prov:atTime "2026-02-11T10:30:00Z"^^xsd:dateTime ;
        ex:mechanism "direct" .
```

This is directly relevant to our CAUSED_BY edge, which carries a `mechanism` property (`direct` | `inferred`). In PROV-O terms, CAUSED_BY corresponds to `wasInformedBy` (unqualified) or `qualifiedCommunication` (qualified, carrying mechanism metadata).

**Key insight**: The qualification pattern maps naturally to Neo4j relationship properties. A PROV-O qualified relation with `atTime` and custom properties maps to a Neo4j edge with those same properties. The difference is representational: PROV-O uses an intermediate node (reification), while Neo4j uses first-class edge properties.

### 1.3 Influence Hierarchy

All PROV-O relations are subproperties of `wasInfluencedBy`, and all qualified classes inherit from `Influence`. The influence classes subdivide into three typed categories based on what entity influenced:

- **EntityInfluence** (influencer is an Entity): Usage, Derivation, PrimarySource, Quotation, Revision, Start, End
- **ActivityInfluence** (influencer is an Activity): Generation, Communication, Invalidation
- **AgentInfluence** (influencer is an Agent): Attribution, Association, Delegation

This hierarchy enables reasoning: if you know something was influenced, you can query whether it was generated, derived, attributed, etc. Our edge types do not currently participate in any influence hierarchy.

### 1.4 Mapping PROV-O to Context-Graph

| PROV-O Concept | Context-Graph Mapping | Notes |
|----------------|----------------------|-------|
| `prov:Activity` | `:Event` node | Events are activities -- they occur over time and act upon entities |
| `prov:Entity` | `:Entity` node | Tools, agents, resources are entities used/generated by activities |
| `prov:Agent` | `:Entity` node (type=agent) | Agents are a specialization of Entity in PROV-O; we model them as Entity nodes with `entity_type=agent` |
| `prov:SoftwareAgent` | `:Entity` node (type=agent) | Our AI agents are software agents |
| `prov:Bundle` | Session boundary | A session is a named set of provenance assertions |
| `prov:Plan` | Procedural memory patterns (future) | P-Plan extends this for workflow templates |
| `prov:Collection` | (no mapping) | Could model tool parameter sets or context windows |
| `prov:wasInformedBy` | `CAUSED_BY` edge (mechanism=direct) | Activity-to-activity dependency via `parent_event_id` |
| `prov:used` | `REFERENCES` edge (role=tool) | Activity consuming an entity |
| `prov:wasGeneratedBy` | `REFERENCES` edge (role=object, direction reversed) | Entity produced by an activity |
| `prov:wasAttributedTo` | `REFERENCES` edge (role=subject) | Entity attributed to an agent |
| `prov:wasAssociatedWith` | Implicit (agent_id on Event) | Activity performed by an agent |
| `prov:actedOnBehalfOf` | (no mapping) | Agent delegation -- relevant for agent-invoking-agent patterns |
| `prov:wasDerivedFrom` | `SIMILAR_TO` edge (loose) | Entity transformation; our SIMILAR_TO is semantic, not derivational |
| `prov:alternateOf` | `SUMMARIZES` edge (partial) | Summary is an alternate representation of source events |
| `prov:specializationOf` | (no mapping) | Could model event type hierarchy |
| `prov:wasStartedBy` / `prov:wasEndedBy` | `occurred_at` / `ended_at` fields | Temporal bounds on events |
| (no PROV mapping) | `FOLLOWS` edge | PROV-O has no temporal sequencing relation |
| (no PROV mapping) | `SIMILAR_TO` edge | PROV-O has no semantic similarity concept |

### 1.5 What We Gain from PROV-O Grounding

**Interoperability**: Any system that understands PROV-O can interpret our causal and attribution edges. This includes provenance-aware scientific workflow systems, data lineage tools, and compliance frameworks.

**Formal semantics**: PROV-O's OWL axioms enable reasoning. For example, if Event A `wasInformedBy` Event B, and Event B `wasInformedBy` Event C, a reasoner can infer a transitive provenance chain. Our CAUSED_BY edges currently lack this formal transitivity.

**Qualified metadata**: The qualification pattern provides a principled way to attach metadata to edges (like `mechanism: direct|inferred` on CAUSED_BY) rather than using ad-hoc edge properties.

**Vocabulary recognition**: Using `wasInformedBy` instead of `CAUSED_BY` means external systems immediately understand the semantics without consulting our documentation.

**Bundle support**: PROV-O's Bundle concept (provenance of provenance) can formally describe our re-projection model: the Neo4j graph is a Bundle derived from the Redis event stream.

### 1.6 What We Lose from Full PROV-O Adoption

**Traversal optimization**: PROV-O relation names are verbose and describe provenance semantics, not traversal intent. Our current names (FOLLOWS, CAUSED_BY, SIMILAR_TO, REFERENCES, SUMMARIZES) are optimized for intent-aware retrieval (ADR-0009). Replacing them with PROV-O terms would break the clean mapping between edge type and query intent.

**Simplicity**: PROV-O's three tiers and qualification pattern introduce conceptual overhead. Our developers need to understand Entity/Activity/Agent distinctions, qualified vs. unqualified forms, and the influence hierarchy. Our current schema is self-documenting.

**Coverage**: PROV-O does not cover temporal sequencing (FOLLOWS) or semantic similarity (SIMILAR_TO). These would remain custom vocabulary regardless.

**Property graph fit**: PROV-O is designed for RDF triples, not property graphs. The qualification pattern (intermediate nodes for edge metadata) is unnecessary in Neo4j where edges carry properties natively. Adopting the full qualification pattern in Neo4j would mean creating intermediate nodes for every edge annotation, which is both wasteful and counter to property graph idioms.

### 1.7 Recommendation: PROV-O as Conceptual Layer, Not Implementation Layer

**Use PROV-O as the conceptual vocabulary** mapped to our operational vocabulary:

```
Conceptual (PROV-O)          Operational (Neo4j)         Mapping
prov:wasInformedBy        --> CAUSED_BY                   direct
prov:used                 --> REFERENCES (role=tool)      direct
prov:wasGeneratedBy       --> REFERENCES (role=object)    reversed direction
prov:wasAttributedTo      --> REFERENCES (role=subject)   direct
prov:alternateOf          --> SUMMARIZES                  partial
(custom)                  --> FOLLOWS                     no PROV-O equivalent
(custom)                  --> SIMILAR_TO                  no PROV-O equivalent
```

This is exactly what ADR-0009's amendment already proposes. The recommendation is to formalize this mapping table in ADR-0011 and add a PROV-O export function that translates Neo4j edges to PROV-O triples for interoperability when needed.

---

## 2. Workflow Provenance Extensions: P-Plan and ProvONE

### 2.1 P-Plan: Plans and Steps

P-Plan extends PROV-O to model the plans that guided execution. Its core contribution is the distinction between **planned** (abstract) and **executed** (concrete) workflow elements.

**Key classes:**
- `p-plan:Plan` -- subclass of `prov:Plan` (which is subclass of `prov:Entity`). Represents the intended workflow.
- `p-plan:Step` -- a planned activity within a plan. Connected via `isStepOfPlan`.
- `p-plan:Variable` -- a planned input or output. Connected via `isVariableOfPlan`, `hasInputVar`, `hasOutputVar`.
- `p-plan:Activity` -- subclass of `prov:Activity`. An actual execution that `correspondsToStep` a planned Step.
- `p-plan:Entity` -- subclass of `prov:Entity`. An actual data item that `correspondsToVariable` a planned Variable.

**Key properties:**
- `p-plan:isPreceededBy` -- transitive ordering of Steps within a Plan. This is the closest formal precedent to our FOLLOWS edge but models *planned* ordering, not *observed* ordering.
- `p-plan:correspondsToStep` -- links an executed Activity to the planned Step it implements.
- `p-plan:correspondsToVariable` -- links an executed Entity to the planned Variable it instantiates.

**Relevance to procedural memory (ADR-0007 Tier 5):**

P-Plan provides the formal model for our procedural memory tier. When the system learns that "for task X, the agent typically invokes tools A, B, C in that order," this is exactly a P-Plan Plan with Steps connected by `isPreceededBy`. Future event traces that follow this pattern `correspondsToStep` the abstract plan.

The plan-execution duality is powerful: abstract plans (procedural memory) are `prov:Entity` subclasses, while concrete executions (episodic memory) are `prov:Activity` subclasses. This formalism cleanly separates the two memory tiers.

**Gap for our use case**: P-Plan assumes plans are static and declared before execution. Agent plans are dynamic -- the agent decides the next tool at each step based on LLM reasoning. P-Plan would need to be extended with a concept of "emergent plan" that is reconstructed from execution traces rather than declared a priori.

### 2.2 ProvONE: Scientific Workflow Provenance

ProvONE extends PROV-O with computational workflow concepts specific to scientific computing:

**Key classes:**
- `provone:Program` -- a computational task, atomic or composite (nested). Has `hasInPort` and `hasOutPort`.
- `provone:Port` -- input/output connection point on a Program. Typed and constrained.
- `provone:Channel` -- a data flow connection between an output Port of one Program and an input Port of another.
- `provone:Execution` -- runtime trace of a Program. Extends `prov:Activity`.
- `provone:Data` -- data artifacts consumed or produced. Extends `prov:Entity`.

**Relevance to context-graph:**

ProvONE's Program/Port/Channel model formalizes tool interfaces. In our domain:
- A `Program` maps to a tool definition (the abstract capability).
- `Port` maps to tool input/output schemas (e.g., MCP's `inputSchema`).
- `Channel` maps to data flow between tools in a multi-step agent workflow.
- `Execution` maps to our Event nodes for tool invocations.

The composite Program concept (programs containing sub-programs) maps to agent-invoking-agent patterns through `parent_event_id` chains.

**Gap**: ProvONE is over-specified for our use case. It models batch scientific pipelines with fixed DAG topologies, not interactive agent sessions with dynamic tool selection. Its Port/Channel model assumes pre-declared data flow, which does not match LLM-driven tool orchestration. We should reference ProvONE's patterns without adopting its full vocabulary.

### 2.3 OPMW: Open Provenance Model for Workflows

OPMW extends both OPM (Open Provenance Model, PROV-O's predecessor), PROV, and P-Plan to make scientific workflow provenance available as Linked Data. Its main contribution is:

- `opmw:WorkflowTemplate` -- abstract workflow definition (extends `p-plan:Plan`)
- `opmw:WorkflowExecutionAccount` -- concrete execution trace (extends `prov:Bundle`)
- `opmw:WorkflowTemplateProcess` / `opmw:WorkflowExecutionProcess` -- plan vs. execution distinction
- `opmw:DataVariable` / `opmw:ParameterVariable` -- typed variables

**Relevance**: OPMW's WorkflowExecutionAccount as a `prov:Bundle` reinforces the idea that a session's trace is a provenance Bundle. This aligns with our recommendation to model sessions as Bundles. Beyond that, OPMW's scientific workflow focus is too distant from our agent domain.

---

## 3. Event/Activity Models: Detailed Analysis

### 3.1 OpenTelemetry GenAI Semantic Conventions

**Status**: Development (pre-stable, rapidly evolving in 2025-2026).

The OTel GenAI conventions define attribute-level vocabulary for tracing generative AI operations. They are not an ontology (no OWL, no formal relations), but they are the de facto standard for the ingestion surface our system must support.

#### Operation Name Taxonomy

The `gen_ai.operation.name` attribute defines seven operation types:

| Operation | Description | Span Kind | Our event_type |
|-----------|-------------|-----------|----------------|
| `chat` | LLM chat completion | CLIENT | `llm.generate` |
| `text_completion` | LLM text completion | CLIENT | `llm.generate` |
| `embeddings` | Embedding generation | CLIENT | `llm.embed` |
| `generate_content` | Content generation | CLIENT | `llm.generate` |
| `create_agent` | Agent creation | CLIENT | `agent.create` |
| `invoke_agent` | Agent invocation | CLIENT/INTERNAL | `agent.invoke` |
| `execute_tool` | Tool execution | INTERNAL | `tool.execute` |

#### Agent Span Attributes

Key attributes for agent spans:
- `gen_ai.agent.id` -- unique agent identifier. Maps to our `agent_id` field.
- `gen_ai.agent.name` -- human-readable name. Maps to Entity node `name` property.
- `gen_ai.agent.description` -- free-form description. Maps to Entity node attributes.
- `gen_ai.conversation.id` -- session/thread identifier. Maps to our `session_id` field.
- `gen_ai.provider.name` -- provider discriminator (e.g., `openai`, `anthropic`, `aws.bedrock`).

#### Tool Execution Model

Three tool types are defined:
- **function** -- client-side execution; the agent generates parameters, the client runs the logic.
- **extension** -- server-side execution; the agent directly calls external APIs.
- **datastore** -- data access; the agent queries structured or unstructured data.

Tool span attributes:
- `gen_ai.tool.name` -- tool identifier. Maps to our `tool_name` field.
- `gen_ai.tool.type` -- one of function/extension/datastore.
- `gen_ai.tool.call.id` -- call identifier for correlation.
- `gen_ai.tool.call.arguments` -- input parameters (opt-in, may contain PII).
- `gen_ai.tool.call.result` -- output (opt-in, may contain PII).
- `gen_ai.tool.description` -- tool description.
- `gen_ai.tool.definitions` -- array of available tool definitions (opt-in).

#### Span Hierarchy

OTel models agent workflows as a span tree:
```
invoke_agent (CLIENT/INTERNAL)
  |-- chat (CLIENT)          # LLM inference call
  |     |-- gen_ai events    # input/output message events
  |-- execute_tool (INTERNAL) # tool execution
  |-- chat (CLIENT)          # follow-up LLM call
  |-- execute_tool (INTERNAL) # another tool call
```

The parent-child span relationship maps directly to our `parent_event_id` field and CAUSED_BY edges. A child span's `parent_span_id` becomes our `parent_event_id`.

#### MCP Integration

OTel now includes semantic conventions for Model Context Protocol operations. MCP tool calls are compatible with `execute_tool` spans. If MCP instrumentation detects that outer GenAI instrumentation is already tracing the tool execution, it should not create a separate span but instead add MCP-specific attributes to the existing tool execution span.

#### Alignment Assessment

| OTel Convention | Our Schema | Gap |
|-----------------|-----------|-----|
| `gen_ai.operation.name` | `event_type` | We use dot-namespaced types; OTel uses underscore-separated. Need mapping table. |
| `gen_ai.agent.id` | `agent_id` | Direct mapping. |
| `gen_ai.conversation.id` | `session_id` | Direct mapping. |
| `gen_ai.tool.name` | `tool_name` | Direct mapping. |
| Parent span ID | `parent_event_id` | Direct mapping. |
| `gen_ai.tool.type` | (not modeled) | We have no tool type classification. Should add to Entity node attributes. |
| `gen_ai.provider.name` | (not modeled) | We have no provider field. Should consider for Entity node metadata. |
| Span events (input/output messages) | `payload_ref` | OTel inlines message content; we reference external payloads. |
| Token usage metrics | (not modeled) | OTel tracks `input_tokens`, `output_tokens`. Could be Event attributes. |
| Tool definitions | (not modeled) | OTel tracks available tools. Could inform Entity node attributes. |

### 3.2 Event Ontology (motools)

The Event Ontology (EO) defines events as "an arbitrary classification of a space/time region, by a cognitive agent." Its decomposition of event participants is:

- **eo:agent** -- active performer/driver of the event
- **eo:factor** -- passive entity with a role in the event (e.g., instrument, material)
- **eo:product** -- entity produced by the event
- **eo:place** -- spatial location
- **eo:time** -- temporal anchoring (links to Timeline Ontology: `tl:Instant`, `tl:Interval`)
- **eo:sub_event** -- mereological decomposition (event composed of sub-events)

**Relevance to REFERENCES edge roles:**

The EO's agent/factor/product trichotomy provides formal grounding for our REFERENCES edge `role` values:
- `role=subject` maps to `eo:agent` (the active performer)
- `role=tool` maps to `eo:factor` (the instrument used)
- `role=object` maps to `eo:product` (the thing produced)
- `role=target` has no direct EO mapping (but maps to schema.org's `target`)

The Timeline Ontology integration is relevant for our FOLLOWS edge. The TL ontology distinguishes between `tl:Instant` (a point in time) and `tl:Interval` (a duration). Our events with both `occurred_at` and `ended_at` are intervals; events with only `occurred_at` are instants. The FOLLOWS edge represents temporal ordering between instants/intervals within a session.

**Gap**: The Event Ontology is designed for cultural and media events (concerts, performances). It has no concept of causality, provenance, derived knowledge, or computational processes. It is too lightweight for our needs as a primary model but provides useful participation patterns.

### 3.3 Simple Event Model (SEM)

SEM provides a domain-independent event model with minimal ontological commitment:

**Core classes:**
- `sem:Event` -- the core event class
- `sem:Actor` -- participant in events (agent)
- `sem:Place` -- where events occur
- `sem:Time` -- when events occur (links to OWLTIME)
- `sem:Core` -- base class for Event, Actor, Place, Time

**Participation and roles:**
- `sem:Role` -- classifies participation. An Actor has a Role in an Event.
- `sem:RoleType` -- taxonomy of role types
- `sem:hasActor` -- connects Event to Actor
- `sem:hasPlace` -- connects Event to Place
- `sem:hasTime` -- connects Event to Time

**Event classification:**
- `sem:EventType` -- classifies events into a type taxonomy
- `sem:eventType` -- connects an Event to its EventType

**Mereological relations:**
- `sem:subEventOf` -- part-whole relation between events (event A is part of event B)
- `sem:subTypeOf` -- type hierarchy (EventType A is a subtype of EventType B)

**Relevance to context-graph:**

SEM's `sem:EventType` hierarchy provides a formal model for our dot-namespaced event types. Currently, `event_type` is a free-form string (e.g., `agent.invoke`, `tool.execute`, `llm.generate`). SEM suggests formalizing this as a type taxonomy:

```
sem:EventType "agent"
  sem:subTypeOf "agent.invoke"
  sem:subTypeOf "agent.create"
  sem:subTypeOf "agent.terminate"

sem:EventType "tool"
  sem:subTypeOf "tool.execute"
  sem:subTypeOf "tool.error"

sem:EventType "llm"
  sem:subTypeOf "llm.generate"
  sem:subTypeOf "llm.embed"
```

SEM's Role-based participation model formalizes our REFERENCES edge `role` property. In SEM, the relationship between an Actor and an Event is mediated by a Role, which classifies the nature of participation. This is exactly what our `role` property does (subject, object, tool, target).

SEM's `sem:subEventOf` is relevant for grouping events into episodes (traces). A trace is a composite event whose sub-events are the individual steps. This maps to our `trace_id` grouping and could formalize episode boundaries for the episodic memory tier.

**Gap**: SEM has no causality modeling, no provenance, no similarity, and no summarization. It is intentionally minimal. It provides useful structural patterns but cannot serve as the primary ontology.

### 3.4 Event-Model-F (DOLCE+DnS Ultralite)

Event-Model-F is the most comprehensive event ontology, built on the DOLCE+DnS Ultralite (DUL) foundational ontology. It provides three inter-event relationship patterns:

**Mereology Pattern** (part-whole):
- `F:EventCompositionSituation` -- a situation where one event is composite
- `F:Composite` -- the whole event
- `F:Component` -- the part events
- Supports temporal constraints on components (overlapping, disjoint, ordered)

This maps to our session/trace hierarchy: a session is a Composite containing Component events. The temporal constraint facility could formalize the ordering semantics of our FOLLOWS edge within a composition.

**Causality Pattern** (cause-effect):
- `F:Cause` -- an event classified as a cause
- `F:Effect` -- an event classified as an effect
- `F:CausalSituation` -- the situation asserting causation
- `F:Justification` -- the theory or evidence justifying the causal claim

The Justification concept is directly relevant to our CAUSED_BY edge's `mechanism` property. A `mechanism=direct` CAUSED_BY corresponds to a causal situation with justification "explicit parent_event_id reference." A `mechanism=inferred` CAUSED_BY corresponds to a causal situation with justification "payload analysis by enrichment pipeline."

**Correlation Pattern** (shared cause):
- `F:Correlate` -- events that share a correlation
- `F:CorrelationSituation` -- the situation asserting correlation
- `F:Justification` -- mathematical or theoretical basis

This could formalize our SIMILAR_TO edge. Two events are correlated (similar) with a justification based on embedding cosine similarity exceeding a threshold. The correlation pattern explicitly models the basis for claiming a relationship, which is stronger than our current `score` property alone.

**Participation Pattern**:
- `F:EventParticipationSituation` -- situation where entities participate in events
- `F:Participant` -- an entity with a classified role in an event

This parallels the Event Ontology's agent/factor/product decomposition and SEM's Role-based participation.

**Assessment**: Event-Model-F is academically rigorous but overly complex for our operational needs. Its DUL/DOLCE foundation requires understanding a deep upper ontology stack. However, the three patterns (mereology, causality, correlation) with explicit justification provide useful conceptual architecture. We should adopt the *pattern* (justified causal and correlative relationships) without adopting the full DOLCE ontology.

### 3.5 ABC Ontology (Harmony Project)

The ABC ontology was developed for digital library interoperability, with first-class treatment of temporality and actuality:

- **Temporality**: Changes in objects over time are modeled explicitly. Objects have lifecycle states (creation, modification, versioning).
- **Actuality**: An entity can have multiple "actualities" -- different states or representations at different times.
- **Actions**: The ontology models actions (who, what, when, where) as first-class events.

**Relevance**: The temporality model is relevant to our FOLLOWS edge (temporal backbone) and the actuality concept maps to our SUMMARIZES edge (a summary is an alternate actuality of the source events). The ABC ontology's explicit "who, what, when, where" decomposition aligns with our intent classification (why/when/what/related).

**Gap**: ABC is designed for digital library metadata, not computational provenance. It is historically interesting but has been largely superseded by PROV-O for provenance use cases.

---

## 4. Key Questions Answered

### 4.1 Can PROV-O serve as our foundational ontology for causal edges and attribution?

**Yes, with qualifications.**

PROV-O should serve as the **conceptual foundation** for our causal and attribution edges. The mapping is natural:

- `CAUSED_BY` grounds in `prov:wasInformedBy` (activity-to-activity causal dependency)
- `REFERENCES (role=subject)` grounds in `prov:wasAttributedTo` (entity attributed to agent)
- `REFERENCES (role=tool)` grounds in `prov:used` (activity consuming an entity)
- `REFERENCES (role=object)` grounds in inverse of `prov:wasGeneratedBy` (entity produced by activity)

However, PROV-O should **not replace** our operational edge type names. The operational names (CAUSED_BY, FOLLOWS, SIMILAR_TO, REFERENCES, SUMMARIZES) are optimized for intent-aware traversal (ADR-0009). PROV-O terms are optimized for provenance interchange.

The recommendation is a **dual vocabulary approach**:
- **Operational vocabulary**: Our 5 edge types, used in Neo4j traversal and API responses
- **Conceptual vocabulary**: PROV-O terms, used in formal documentation, interchange formats, and interoperability mappings

This is consistent with ADR-0009's existing PROV-DM compatibility mapping table.

### 4.2 Which event ontology best fits our dot-namespaced event types?

**SEM's EventType hierarchy is the best structural fit, combined with OTel GenAI conventions for the actual vocabulary.**

Our dot-namespaced event types (`agent.invoke`, `tool.execute`, `llm.generate`) form a two-level hierarchy:
- Level 1: Category (`agent`, `tool`, `llm`, `retriever`, `chain`)
- Level 2: Action (`invoke`, `execute`, `generate`, `query`, `run`)

SEM's `sem:EventType` with `sem:subTypeOf` provides the formal mechanism for this hierarchy. The actual vocabulary should be derived from OTel GenAI conventions:

| OTel gen_ai.operation.name | Our event_type | SEM EventType |
|---------------------------|----------------|---------------|
| `invoke_agent` | `agent.invoke` | `AgentEvent > InvokeAgent` |
| `create_agent` | `agent.create` | `AgentEvent > CreateAgent` |
| `execute_tool` | `tool.execute` | `ToolEvent > ExecuteTool` |
| `chat` | `llm.generate` | `LLMEvent > Chat` |
| `text_completion` | `llm.generate` | `LLMEvent > TextCompletion` |
| `embeddings` | `llm.embed` | `LLMEvent > Embeddings` |
| `generate_content` | `llm.generate` | `LLMEvent > GenerateContent` |

The SEM pattern gives us a type taxonomy; OTel gives us the leaf-level vocabulary; our dot-namespace convention gives us the serialization format.

### 4.3 What is the gap between our current schema and a PROV-O-grounded model?

**Summary of gaps:**

| Gap | Severity | Resolution |
|-----|----------|------------|
| **No formal Entity/Activity/Agent distinction** | Medium | Our Event nodes are PROV Activities; our Entity nodes are PROV Entities. Agent is a subtype of Entity. Formalize by adding PROV type annotations. |
| **FOLLOWS has no PROV equivalent** | Low | Define as custom extension `cg:follows` (temporal sequencing). P-Plan's `isPreceededBy` is the closest formal precedent but models planned, not observed, ordering. |
| **SIMILAR_TO has no PROV equivalent** | Low | Define as custom extension `cg:similarTo` (semantic similarity with score). No provenance ontology models this. It comes from the graph memory literature (MAGMA). |
| **SUMMARIZES loosely maps to alternateOf** | Low | `prov:alternateOf` captures "different aspect of the same thing" which partially fits summaries. Extend with `cg:summarizes` for hierarchical compression semantics. |
| **CAUSED_BY conflates wasInformedBy and wasGeneratedBy** | Medium | Our `CAUSED_BY` covers both activity-to-activity (wasInformedBy) and entity-generated-by-activity (wasGeneratedBy) relationships. Consider splitting or documenting the dual mapping. |
| **REFERENCES conflates used, wasGeneratedBy, and wasAttributedTo** | Medium | Our `REFERENCES` edge carries a `role` property that disambiguates. This is valid but means one edge type maps to three PROV-O relations. The export function must use the `role` to select the correct PROV-O term. |
| **No explicit prov:wasAssociatedWith** | Low | Our `agent_id` on Event nodes implicitly captures this association. Could add explicit REFERENCES edge with `role=performer` to formalize it. |
| **No prov:actedOnBehalfOf** | Medium | No modeling of agent delegation. When agent A invokes agent B, we have `parent_event_id` (CAUSED_BY) but no formal delegation relation. PROV-O's `actedOnBehalfOf` would be valuable for multi-agent systems. |
| **No prov:Bundle for sessions** | Low | Sessions are implicit (grouped by `session_id`). Could formalize as PROV Bundles for provenance-of-provenance tracking. |
| **Qualification pattern not used** | Low | Edge metadata (mechanism, score, delta_ms) is stored as Neo4j edge properties, which is the property graph equivalent of PROV-O's qualification pattern. No action needed for Neo4j; qualification would be needed for RDF export. |

### 4.4 Are there existing mappings between PROV-O and OpenTelemetry?

**No formal published mapping exists**, but the structural alignment is strong and a mapping can be derived:

| OTel Concept | PROV-O Concept | Mapping Rationale |
|-------------|----------------|-------------------|
| Trace | `prov:Bundle` | A trace is a named collection of provenance assertions (spans). |
| Span | `prov:Activity` | A span represents a unit of work bounded by start and end times. |
| Span parent-child | `prov:wasInformedBy` | Child span was informed by (caused by) parent span. |
| Span Link | `prov:wasDerivedFrom` or `prov:wasInformedBy` | Links represent causal relationships across traces. |
| Resource | `prov:Entity` | The thing being observed (service, host, container). |
| Span Events | `prov:InstantaneousEvent` | Events within a span are instants within an activity. |
| `gen_ai.agent.id` | `prov:Agent` identifier | The agent performing the activity. |
| `gen_ai.tool.name` | `prov:Entity` (used) | The tool is an entity used by the activity. |
| Span attributes | Qualified relation properties | Attributes on spans are metadata on the activity/influence. |
| Span status | (no mapping) | PROV-O does not model operation success/failure. |
| Token metrics | (no mapping) | PROV-O has no concept of computational resource consumption. |

The key structural parallel is:
- **OTel Span** = **PROV-O Activity** (bounded temporal unit of work)
- **Span parent-child** = **wasInformedBy** (causal dependency chain)
- **OTel Resource** = **PROV-O Entity** (the thing being acted upon)

This mapping is not published as a formal standard, but the alignment is natural because both OTel and PROV-O model the same underlying reality: activities performed by agents that consume and produce entities. The W3C Trace Context standard (used by OTel for context propagation) and W3C PROV share organizational heritage at the W3C, though they were developed by different working groups without formal cross-referencing.

**Recommendation for context-graph**: Implement a bidirectional mapping layer:
1. **Ingest**: OTel spans -> our event schema (already planned, ADR-0001 item 7)
2. **Export**: Our events -> PROV-O triples (new, for interoperability)

The mapping layer translates OTel span hierarchies into PROV-O provenance graphs via our event store as the intermediate representation.

---

## 5. Synthesis: Ontology Grounding Strategy

### 5.1 Layered Adoption

Based on this analysis, the recommended ontology grounding for provenance and events is:

```
Layer 3 (Interchange):  PROV-O (for export/interoperability)
Layer 2 (Ingestion):    OTel GenAI Conventions (for ingest vocabulary)
Layer 1 (Operational):  Context-graph edge types (FOLLOWS, CAUSED_BY,
                        SIMILAR_TO, REFERENCES, SUMMARIZES)
Layer 0 (Structural):   SEM patterns (event types, role-based participation)
                        + Event-Model-F patterns (justified causality/correlation)
```

### 5.2 Specific Adoptions for ADR-0011

**Must adopt:**
1. PROV-O Entity/Activity/Agent as the conceptual type system for our nodes
2. PROV-O relation vocabulary as the conceptual grounding for CAUSED_BY and REFERENCES
3. OTel GenAI `gen_ai.operation.name` values as the canonical event type vocabulary
4. OTel GenAI agent/tool attributes as the ingestion field mapping

**Should adopt:**
5. SEM `EventType` hierarchy pattern for formalizing the dot-namespace event type taxonomy
6. SEM Role pattern for formalizing REFERENCES edge `role` values
7. Event-Model-F's justified causality pattern (explicit `mechanism`/`justification` on causal edges)
8. P-Plan's Plan/Step model for procedural memory tier (Tier 5) when implemented

**Should define as custom extensions (no standard covers):**
9. `cg:follows` -- temporal sequencing edge (observed ordering within a session)
10. `cg:similarTo` -- semantic similarity edge (cosine similarity above threshold)
11. `cg:summarizes` -- hierarchical compression edge (summary of source events)

**May reference for future extension:**
12. PROV-O `actedOnBehalfOf` for multi-agent delegation
13. PROV-O `Bundle` for session-level provenance boundaries
14. ProvONE Program/Port model for formal tool interface descriptions

### 5.3 Mapping Table (Consolidated)

This table consolidates the recommended formal grounding for every element of our current schema:

| Context-Graph Element | PROV-O Grounding | OTel Grounding | SEM/EO Grounding | Custom |
|----------------------|-----------------|----------------|-------------------|--------|
| Event node | `prov:Activity` | Span | `sem:Event` | -- |
| Entity node | `prov:Entity` | Resource | `sem:Actor` | -- |
| Entity (type=agent) | `prov:SoftwareAgent` | `gen_ai.agent.id` | -- | -- |
| Summary node | `prov:Entity` + `prov:alternateOf` | -- | -- | `cg:Summary` |
| session_id | `prov:Bundle` | `gen_ai.conversation.id` | -- | -- |
| agent_id | `prov:wasAssociatedWith` | `gen_ai.agent.id` | `sem:hasActor` | -- |
| tool_name | `prov:used` | `gen_ai.tool.name` | `sem:Role(instrument)` | -- |
| event_type | -- | `gen_ai.operation.name` | `sem:EventType` | dot-namespace |
| parent_event_id | `prov:wasInformedBy` | parent_span_id | `sem:subEventOf` | -- |
| CAUSED_BY | `prov:wasInformedBy` | parent-child span | F:CausalSituation | mechanism property |
| FOLLOWS | -- | span ordering by time | `tl:after` (Timeline) | `cg:follows` |
| REFERENCES | `prov:used` / `wasAttributedTo` / `wasGeneratedBy` | -- | `sem:Role` | role property |
| SIMILAR_TO | -- | -- | F:CorrelationSituation | `cg:similarTo` |
| SUMMARIZES | `prov:alternateOf` (partial) | -- | -- | `cg:summarizes` |

---

## 6. Impact on Current ADR-0009 PROV-DM Mapping

The existing mapping in ADR-0009's amendments section is directionally correct but can be refined based on this analysis:

| ADR-0009 Current | Recommended Refinement | Rationale |
|-----------------|----------------------|-----------|
| `CAUSED_BY -> wasGeneratedBy, wasInformedBy` | `CAUSED_BY -> wasInformedBy` (primary). When mechanism=direct and links Activity->Activity via parent_event_id, use `wasInformedBy`. `wasGeneratedBy` applies only when an Entity is created by an Activity, which is modeled via REFERENCES, not CAUSED_BY. | Cleaner separation of concerns. |
| `FOLLOWS -> (no direct mapping)` | `FOLLOWS -> custom cg:follows`. Cite P-Plan `isPreceededBy` as nearest precedent. | Acknowledges the gap formally. |
| `REFERENCES -> wasAttributedTo, used` | `REFERENCES -> used (role=tool), wasAttributedTo (role=subject), inverse wasGeneratedBy (role=object)`. Add `wasAssociatedWith` for role=performer if added. | Role-differentiated mapping. |
| `SIMILAR_TO -> wasDerivedFrom (loose)` | `SIMILAR_TO -> custom cg:similarTo`. Drop `wasDerivedFrom` mapping -- derivation implies transformation, not similarity. | `wasDerivedFrom` has wrong semantics for cosine similarity. |
| `SUMMARIZES -> alternateOf, specializationOf` | `SUMMARIZES -> alternateOf` (summary is an alternate representation). Drop `specializationOf` -- specialization implies more detail, but summaries are less detailed. | `specializationOf` has inverted semantics. |

---

## References

### W3C PROV Family
- PROV-O: The PROV Ontology -- https://www.w3.org/TR/prov-o/
- PROV-DM: The PROV Data Model -- https://www.w3.org/TR/prov-dm/
- PROV Namespace -- https://www.w3.org/ns/prov

### Workflow Provenance Extensions
- P-Plan Ontology -- https://www.opmw.org/model/p-plan/
- OPMW-PROV -- https://www.opmw.org/interoperability.html
- ProvONE -- http://jenkins-1.dataone.org/jenkins/view/Documentation%20Projects/job/ProvONE-Documentation-trunk/ws/provenance/ProvONE/v1/provone.html
- ProvONE OWL -- https://github.com/DataONEorg/sem-prov-ontologies

### OpenTelemetry GenAI
- GenAI Semantic Conventions -- https://opentelemetry.io/docs/specs/semconv/gen-ai/
- GenAI Agent Spans -- https://opentelemetry.io/docs/specs/semconv/gen-ai/gen-ai-agent-spans/
- GenAI Client Spans (execute_tool) -- https://opentelemetry.io/docs/specs/semconv/gen-ai/gen-ai-spans/
- MCP Semantic Conventions -- https://opentelemetry.io/docs/specs/semconv/gen-ai/mcp/
- GenAI Events -- https://opentelemetry.io/docs/specs/semconv/gen-ai/gen-ai-events/

### Event Ontologies
- Event Ontology (motools) -- https://motools.sourceforge.net/event/event.html
- Simple Event Model (SEM) -- https://semanticweb.cs.vu.nl/2009/11/sem/
- Event-Model-F (DOLCE+DnS) -- https://arxiv.org/abs/2411.16609
- ABC Ontology -- Lagoze & Hunter, "The ABC Ontology and Model," Journal of Digital Information

### Additional References
- P-Plan augmenting PROV -- https://ceur-ws.org/Vol-951/paper6.pdf
- PROV-O mapping to BFO -- https://www.nature.com/articles/s41597-025-04580-1
- W3C PROV extensions survey -- https://blogs.ncl.ac.uk/paolomissier/2021/02/07/w3c-prov-some-interesting-extensions-to-the-core-standard/
- Event-based ontology comparison -- http://paper.ijcsns.org/07_book/202305/20230523.pdf
